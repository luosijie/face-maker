<template>
  <view class="playboard">
    <canvas
      type="2d"
      id="canvas"
      class="canvas"
      bindtouchstart="touchstart"
      bindtouchmove="touchmove"
      bindtouchend="touchend"
    />
    <image
      class="icon-add"
      src="../assets/images/icon-add-image.png"
      alt="添加图片"
      bindtouchstart="chooseImage"
    />
  </view>
</template>

<script>
import { createComponent } from '@mpxjs/core'
import store from '../store'
const imageUrl = 'https://res.wx.qq.com/wxdoc/dist/assets/img/0.4cb08bb4.jpg'
// import example from '../assets/images/example.jpeg'
const ACTION_TYEP = {
  MOVE: 'MOVE', // 移动
  SCALE: 'SCALE', // 缩放
  ROTATE: 'ROTATE', // 旋转
  DELETE: 'DELETE', // 旋转
  NULL: 'NULL' // 空闲
}

createComponent({
  data: {
    startTouches: [],
    startSelected: {
      left: 0,
      top: 0
    },
    actionType: '', // move, scale, rotate
    image: {
      move: null,
      scale: null,
      delete: null,
      rotate: null
    }
  },
  computed: {
    mode() {
      return store.state.mode
    },
    canvas() {
      return store.state.canvas
    },
    ctx() {
      return store.state.ctx
    },
    elements() {
      return store.state.elements
    },
    activeIndex() {
      return store.state.activeIndex
    },
    dpr() {
      return wx.getSystemInfoSync().pixelRatio
    }
  },
  watch: {
    elements() {
      console.log('canvas elements change')
      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height)
      for (let i = 0; i < this.elements.length; i++) {
        const ele = this.elements[i]
        if (ele.type === 'image') {
          this.ctx.save()
          const left = ele.left - this.ctx.canvas.width / this.dpr / 2
          const top = ele.top - this.ctx.canvas.height / this.dpr / 2
          this.ctx.translate(
            this.ctx.canvas.width / this.dpr / 2,
            this.ctx.canvas.height / this.dpr / 2
          )
          this.ctx.scale(ele.scale, ele.scale)
          this.ctx.drawImage(ele.data, left, top, ele.width, ele.height)
          this.ctx.restore()
        }
        if (ele.type === 'text') {
          this.initController('text', (offsetLeft, offsetTop) => {
            this.ctx.font = `${ele.size}px sans-serif`
            this.ctx.textBaseline = 'top'
            this.ctx.fillText(ele.data, ele.left - offsetLeft, ele.top - offsetTop)
          })
        }
      }
      this.drawGrid()
    }
  },
  methods: {
    /**
     * 检测鼠标是否与物体发生碰撞
     * @param { Number } x 鼠标坐标X
     * @param { Number } y 鼠标坐标Y
     * @param { Object } y canvas元素
     * @return { Boolean } 是否发生碰撞
     */
    isCollided(x, y, ele) {
      const controllerSize = this.convert2ControllerSize(ele)
      const unrotatedSize = this.convert2unrotatedSize(
        x,
        y,
        controllerSize.centerX,
        controllerSize.centerY,
        ele.rotate
      )
      return (
        unrotatedSize.left > controllerSize.left &&
        unrotatedSize.top > controllerSize.top &&
        unrotatedSize.left < controllerSize.left + controllerSize.width &&
        unrotatedSize.top < controllerSize.top + controllerSize.height
      ) ? unrotatedSize
        : null
    },
    convert2ControllerSize(ele) {
      let left, top, width, height, centerX, centerY
      if (ele.type === 'text') {
        left = ele.left - 5
        top = ele.top - 5
        width = ele.size * ele.data.length + 10
        height = ele.size + 10
      } else {
        left = ele.left
        top = ele.top
        width = ele.width
        height = ele.height
      }
      centerX = left + width / 2
      centerY = top + height / 2
      return { left, top, width, height, centerX, centerY }
    },
    chooseImage() {
      // wx.chooseImage({
      //   success (res) {
      //     console.log('res', res)
      //   }
      // })
    },
    touchstart(e) {
      this.actionType = ACTION_TYEP.NULL
      this.startTouches = e.touches
      const selected = store.state.elements.find(e => e.type === this.mode)
      if (selected) {
        const controllerSize = this.convert2ControllerSize(selected)
        console.log('controllerSize', controllerSize, e.touches)
        console.log('unrotatedSize', selected)
        // 检测鼠标是否与canvas元素发生碰撞
        const collided = this.isCollided(e.touches[0].x, e.touches[0].y, selected)
        if (collided) {
          this.startSelected = {
            left: selected.left,
            top: selected.top,
            scale: selected.scale,
            rotate: selected.rotate
          }
          const controllerSize = this.convert2ControllerSize(selected)
          console.log('selected------>', selected)
          if (Math.sqrt((collided.left - controllerSize.left) ** 2 + (collided.top - controllerSize.top) ** 2) < 20) {
            console.log('移动模式')
            this.actionType = ACTION_TYEP.MOVE
          } else if (Math.sqrt((collided.left - controllerSize.left - controllerSize.width) ** 2 + (collided.top - controllerSize.top) ** 2) < 20) {
            console.log('删除模式')
            this.actionType = ACTION_TYEP.DELETE
          } else if (Math.sqrt((collided.left - controllerSize.left - controllerSize.width) ** 2 + (collided.top - controllerSize.top - controllerSize.height) ** 2) < 20) {
            console.log('旋转模式')
            this.actionType = ACTION_TYEP.ROTATE
          } else if (Math.sqrt((collided.left - controllerSize.left) ** 2 + (collided.top - controllerSize.top - controllerSize.height) ** 2) < 20) {
            console.log('缩放模式')
            this.actionType = ACTION_TYEP.SCALE
          } else if (e.touches.length === 1) {
            console.log('单指触发')
            this.actionType = ACTION_TYEP.MOVE
          } else if (e.touches.length === 2) {
            console.log('双指触发')
            this.actionType = ACTION_TYEP.SCALE
          }
        }
      }
    },
    touchmove(e) {
      console.log('this.actionType', this.actionType, e.touches)
      if (this.actionType === ACTION_TYEP.MOVE) {
        if (e.touches.length > 1) return
        const x = e.touches[0].x
        const y = e.touches[0].y
        const dx = this.startTouches[0].x - x
        const dy = this.startTouches[0].y - y
        const elements = store.state.elements.slice()
        if (this.mode === 'image') {
          const index = elements.findIndex(e => e.type === 'image')
          // const image = elements.splice(index, 1)[0]
          elements[index].left = this.startSelected.left - dx
          elements[index].top = this.startSelected.top - dy
          store.commit('setElements', elements)
        }
        if (this.mode === 'text') {
          const index = elements.findIndex(e => e.type === 'text')
          // const image = elements.splice(index, 1)[0]
          elements[index].left = this.startSelected.left - dx
          elements[index].top = this.startSelected.top - dy
          store.commit('setElements', elements)
        }
      }
      if (this.actionType === ACTION_TYEP.SCALE) {
        if (e.touches.length !== 2) return
        const startLength = Math.sqrt(
          (this.startTouches[0].x - this.startTouches[1].x) ** 2 +
            (this.startTouches[0].y - this.startTouches[1].y) ** 2
        )
        const endLength = Math.sqrt(
          (e.touches[0].x - e.touches[1].x) ** 2 + (e.touches[0].y - e.touches[1].y) ** 2
        )
        const scale = endLength / startLength
        const elements = store.state.elements
        const index = elements.findIndex(e => e.type === 'image')
        const image = elements.splice(index, 1)[0]
        image.scale = this.startSelected.scale * scale
        elements.push(image)
      }
    },
    touchend(e) {
      this.actionType = ACTION_TYEP.NULL
      console.log('touch-end', e)
    },
    initSelectStatue() {
      //
    },
    convert2unrotatedSize(x, y, ox, oy, r) {
      x = x - ox
      y = y - oy
      return {
        left: x * Math.cos(-r) - y * Math.sin(-r) + ox,
        top: x * Math.sin(-r) + y * Math.cos(-r) + oy
      }
    },
    initCanvas() {
      const query = this.createSelectorQuery()
      const elements = store.state.elements
      query
        .select('#canvas')
        .fields({ node: true, size: true })
        .exec(async res => {
          const canvas = res[0].node
          const ctx = canvas.getContext('2d')
          store.commit('setCanvas', canvas)
          store.commit('setCtx', ctx)

          await this.loadImage('/images/icon-move.png').then(res => {
            console.log('this', this)
            this.image.move = res
          })
          await this.loadImage('/images/icon-scale.png').then(res => {
            this.image.scale = res
          })
          await this.loadImage('/images/icon-delete.png').then(res => {
            this.image.delete = res
          })
          await this.loadImage('/images/icon-rotate.png').then(res => {
            this.image.rotate = res
          })

          canvas.width = res[0].width * this.dpr
          canvas.height = res[0].height * this.dpr
          ctx.scale(this.dpr, this.dpr)

          // 初始化一张背景图
          wx.getImageInfo({
            src: imageUrl,
            success: res => {
              console.log('get-image-url', res)
              const imageData = canvas.createImage()
              imageData.src = imageUrl
              imageData.onload = e => {
                console.log('imageData-loaded', e)
                // ctx.drawImage(res.path, 0, 0, 100, 100)
                const cWidth = canvas.width / this.dpr
                const cHeight = canvas.height / this.dpr
                const data = {
                  type: 'image',
                  data: imageData,
                  left: 0,
                  top: 0,
                  width: 0,
                  height: 0,
                  scale: 1,
                  rotate: 0
                }
                if (res.height > res.width) {
                  const rate = res.height / cHeight
                  data.width = res.width / rate
                  data.height = cHeight
                  data.left = (cWidth - data.width) / 2
                  data.top = 0
                } else {
                  const rate = res.width / cWidth
                  data.height = res.height / rate
                  data.width = cWidth
                  data.left = 0
                  data.top = (cHeight - data.height) / 2
                }
                elements.push(data)
                // store.commit('setElements', elements)// 初始化一段文字
                const text = {
                  type: 'text',
                  data: '请输入文字',
                  size: 50,
                  left: 100,
                  top: 100,
                  rotate: Math.PI / 4
                }
                elements.push(text)
              }
            }
          })
        })
    },
    loadImage(src) {
      const image = this.canvas.createImage()
      image.src = src
      return new Promise((resolve, reject) => {
        try {
          image.onload = e => {
            resolve(image)
            // this.ctx.drawImage(imageMove, left - 10, top - 10, 20, 20)
          }
        } catch (err) {
          reject(err)
        }
      })
    },
    initController(type, fn) {
      if (!this.activeIndex) return
      const activeElement = this.elements[this.activeIndex]
      this.ctx.save()
      // this.ctx.setTextBaseline('top')
      // this.ctx.setTextBaseline('top')
      this.ctx.strokeStyle = '#eee'
      let left, top, width, height
      if (type === 'text') {
        left = activeElement.left - 5
        top = activeElement.top - 5
        width = activeElement.size * activeElement.data.length + 10
        height = activeElement.size + 10
      }
      const offsetLeft = left + width / 2
      const offsetTop = top + height / 2
      this.ctx.translate(offsetLeft, offsetTop)
      this.ctx.rotate(activeElement.rotate)
      this.ctx.setLineDash([10, 5], 5)
      this.ctx.strokeRect(left - offsetLeft, top - offsetTop, width, height)
      // 绘制控制点-移动
      this.ctx.drawImage(this.image.move, left - 10 - offsetLeft, top - 10 - offsetTop, 20, 20)
      // await this.loadImage('/images/icon-move.png').then(res => {
      // })
      // 绘制控制点-缩放
      this.ctx.drawImage(
        this.image.scale,
        left - 10 - offsetLeft,
        top + height - 10 - offsetTop,
        20,
        20
      )
      // 绘制控制点-删除
      this.ctx.drawImage(
        this.image.delete,
        left + width - 10 - offsetLeft,
        top - 10 - offsetTop,
        20,
        20
      )
      // 绘制控制点-旋转
      this.ctx.drawImage(
        this.image.rotate,
        left + width - 10 - offsetLeft,
        top + height - 10 - offsetTop,
        20,
        20
      )
      fn(offsetLeft, offsetTop)
      this.ctx.restore()
    },
    drawGrid() {
      this.ctx.save()
      const lineNums = 3
      const cWidth = this.ctx.canvas.width / this.dpr
      // const cHeight = this.ctx.canvas.height
      const lineGap = cWidth / lineNums
      this.ctx.strokeStyle = '#ccc'
      this.ctx.setLineDash([5, 5])
      // 绘制x轴
      for (let i = 0; i <= lineNums; i++) {
        this.ctx.beginPath()
        this.ctx.moveTo(0, lineGap * i)
        this.ctx.lineTo(cWidth, lineGap * i)
        this.ctx.stroke()
      }
      // 绘制y轴
      for (let i = 0; i <= lineNums; i++) {
        this.ctx.beginPath()
        this.ctx.moveTo(lineGap * i, 0)
        this.ctx.lineTo(lineGap * i, cWidth)
        this.ctx.stroke()
      }
      this.ctx.restore()
    }
  },
  ready() {
    this.initCanvas()
  }
})
</script>

<style lang="stylus">
.playboard
  position relative
  width 100vw
  height 100vw
  background #f8f8f8
.canvas
  width 100vw
  height 100vw
.icon-add
  position absolute
  width 160rpx
  height 160rpx
  left 50%
  top 50%
  margin-top -80rpx
  margin-left -80rpx
</style>

<script type="application/json">
  {
    "component": true
  }
</script>
